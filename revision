# This is a password generator. It included features such as an option to include your own word, and an option to save the password to a 
# file named "password.txt"
# One problem is that if the "custom" word is longer then the length theres no failsafe to reject the word.

import string
import secrets

# Define alphabet: letters, digits, and symbols. Also defines txt file.
alphabet = string.ascii_letters + string.digits + "_@#$%^&*!?"


def generate_password(length=8, word=None):
    """Generate the password with an optional inserted word."""
    if word and len(word) >= length:
        return word  # Word is longer than desired length

    remaining_length = length - (len(word) if word else 0)
    random_part = ''.join(secrets.choice(alphabet) for _ in range(remaining_length))

    if word:
        insert_position = secrets.randbelow(len(random_part) + 1)
        password = random_part[:insert_position] + word + random_part[insert_position:]
    else:
        password = random_part

    return password


def save_password(password, filename="passwords.txt"):
    """Append the password to a text file."""
    with open(filename, "a") as file:
        file.write(password + "\n")
    print(f"Password saved to {filename}")

# NEW: simple yes/no helper so we don't repeat logic
def ask_yes_no(prompt, default=None):
    """Ask a yes/no question and return True for yes, False for no."""
    while True:
        choice = input(prompt).strip().lower()
        if not choice and default is not None:
            choice = default.lower()
        if choice in ("y", "yes"):
            return True
        if choice in ("n", "no"):
            return False
        print("Please enter 'y' or 'n'.")
# NEW: let the user choose what character types go into `alphabet`
def choose_character_set():
    global alphabet  # we keep using the same global variable your function already uses

    print("\nChoose which character types to include in the password:")
    include_lower = ask_yes_no("Include lowercase letters (a-z)? (y/n) [y]: ", default="y")
    include_upper = ask_yes_no("Include uppercase letters (A-Z)? (y/n) [y]: ", default="y")
    include_digits = ask_yes_no("Include digits (0-9)? (y/n) [y]: ", default="y")
    include_symbols = ask_yes_no("Include symbols (_@#$%^&*!?)? (y/n) [y]: ", default="y")

    new_alphabet = ""
    if include_lower:
        new_alphabet += string.ascii_lowercase
    if include_upper:
        new_alphabet += string.ascii_uppercase
    if include_digits:
        new_alphabet += string.digits
    if include_symbols:
        new_alphabet += "_@#$%^&*!?"

    if not new_alphabet:
        print("You must choose at least one character type. Using default set.")
        return  # keep original alphabet

    alphabet = new_alphabet  # update the global used by generate_password


# NEW: handle case where custom word is too long for chosen length
def handle_custom_word_and_length(word, length):
    while word and len(word) >= length:
        print(f"\nYour custom word '{word}' is {len(word)} characters long,")
        print(f"which is not shorter than the desired password length of {length}.")
        print("Choose an option:")
        print("  1) Increase password length to fit the word")
        print("  2) Trim the word to the current password length")
        print("  3) Enter a new (shorter) word")
        print("  4) Remove the custom word")

        choice = input("Enter 1, 2, 3, or 4: ").strip()
        if choice == "1":
            # give at least 2 extra random characters
            min_length = len(word) + 2
            if length < min_length:
                length = min_length
            print(f"Password length increased to {length}.\n")
            break
        elif choice == "2":
            word = word[:length]
            print(f"Word trimmed to '{word}'.\n")
            break
        elif choice == "3":
            new_word = input("Enter a new word (leave blank for none): ").strip()
            word = new_word if new_word else None
            if not word:
                print("No custom word will be used.\n")
                break
        elif choice == "4":
            word = None
            print("Custom word removed.\n")
            break
        else:
            print("Invalid choice. Please try again.\n")

    return word, length
# Main Stuff
try:
    length = int(input("Enter the desired password length: "))
except ValueError:
    length = 8
    print("Invalid input. Using default length of 8.")

word = input("Enter a word to include in the password (leave blank for none): ").strip()
word = word if word else None
# NEW: fix the 'word longer than length' problem
word, length = handle_custom_word_and_length(word, length)

# NEW: let the user customize the character set
choose_character_set()

# NEW: ask how many password suggestions to show at once
try:
    num_suggestions = int(input("\nHow many password suggestions do you want to see at once? (e.g., 3): "))
    if num_suggestions <= 0:
        raise ValueError
except ValueError:
    num_suggestions = 1
    print("Invalid input. Showing 1 suggestion at a time.")
# NEW: generate multiple suggestions until the user picks one
while True:
    passwords = [generate_password(length, word) for _ in range(num_suggestions)]
    print("\nGenerated password(s):")
    for i, pw in enumerate(passwords, start=1):
        print(f"  {i}) {pw}")

    choice = input(
        f"\nEnter the number of the password you like (1-{num_suggestions}), "
        "or 0 to generate new ones: "
    ).strip()

    if choice.isdigit():
        idx = int(choice)
        if idx == 0:
            print("Generating a new set of passwords...\n")
            continue
        if 1 <= idx <= num_suggestions:
            password = passwords[idx - 1]  

    print("Invalid choice. Please enter a valid number.\n")

# Save Option
save_choice = input("Do you want to save this password to file? (y/n): ").lower().strip()
if save_choice == "y":
    save_password(password)
else:
    print("Password not saved.")

print("\nEnd of Program")
